import polars as pl

def downcast_column(series: pl.Series) -> pl.Series:
    dtype = series.dtype

    # 1. BOOLEAN
    if dtype == pl.Boolean:
        return series

    # 2. INTEGER TYPES
    if pl.datatypes.is_integer(dtype):
        min_v = series.min()
        max_v = series.max()

        # signed integers
        if min_v >= pl.Int8().min_value and max_v <= pl.Int8().max_value:
            return series.cast(pl.Int8)
        if min_v >= pl.Int16().min_value and max_v <= pl.Int16().max_value:
            return series.cast(pl.Int16)
        if min_v >= pl.Int32().min_value and max_v <= pl.Int32().max_value:
            return series.cast(pl.Int32)
        return series.cast(pl.Int64)

    # 3. UNSIGNED INTEGERS
    if pl.datatypes.is_unsigned_integer(dtype):
        min_v = series.min()
        max_v = series.max()
        if max_v <= pl.UInt8().max_value:
            return series.cast(pl.UInt8)
        if max_v <= pl.UInt16().max_value:
            return series.cast(pl.UInt16)
        if max_v <= pl.UInt32().max_value:
            return series.cast(pl.UInt32)
        return series.cast(pl.UInt64)

    # 4. FLOAT TYPES
    if pl.datatypes.is_float(dtype):
        # Downcast float64 → float32 if safe
        if dtype == pl.Float64:
            s32 = series.cast(pl.Float32)
            # Check precision loss
            if (series - s32.cast(pl.Float64)).abs().max() < 1e-6:
                return s32
        return series

    # 5. STRING TYPES → consider categorical
    if dtype == pl.String:
        unique_ratio = series.n_unique() / len(series)
        # Convert to categorical if many repeating values
        if unique_ratio < 0.5:
            return series.cast(pl.Categorical)
        return series

    # 6. DATE / DATETIME
    if dtype in (pl.Date, pl.Datetime, pl.Time):
        return series

    # 7. CATEGORICAL
    if dtype == pl.Categorical:
        return series

    # Fallback: return unchanged
    return series


def downcast_df(df: pl.DataFrame) -> pl.DataFrame:
    return df.select([
        downcast_column(df[col]).alias(col)
        for col in df.columns
    ])
